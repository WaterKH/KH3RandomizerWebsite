@page "/spoilerlog"

@using UE4DataTableInterpreter.Enums;
@using System.Text.Json;
@using System.IO;
@using Enums;
@using System.Text.RegularExpressions; 

@inject RandomizerService RandomizerService

<div class="spoiler-log-content">
    <div class="spoiler-log-header">
        <span class="bi bi-door-open" aria-hidden="true"></span>
        <h1 style="align-self: center; margin-left: 25px;"><b>Spoiler</b><b style="color: black"> Log</b></h1>
    </div>

    <div class="row">
        <div class="col-md-6">
            <div class="instructions-section">
                <h3 class="instruction-section-header"><span class="selector" style="background-color: #9555DC;"></span><b style="color: #9555DC;">Instructions</b></h3>

                <br />

                <p style="margin-bottom: 5px;">Upload your <b style="color: #9555DC;">SpoilerLog.json</b> on the right to load a specific seed's Spoiler Log.</p>
                <div class="decorated"><span><b>OR</b></span></div>
                <p>Input the seed name, pools, options and modifications below to manually create a Spoiler Log.</p>
            </div>
        </div>

        <div class="col-md-6">
            <div class="upload-section">
                <span class="side-selector" style="background-color: #9555DC;"></span>
                <label for="input" class="upload-sub-section">
                    <div class="upload-border" style="display: inline-flex;">
                        <span class="bi bi-file-earmark-fill" aria-hidden="true" style="color: grey; font-size: 5.5rem;"></span>
                        <h3 style="align-self: center; margin-left: 25px; margin-top: 10px;"><b style="color: #9555DC;">Click</b><b style="color: black"> to upload Spoiler Log...</b></h3>
                    </div>
                </label>

                <InputFile id="input" class="sr-only" OnChange="@LoadSpoilerLog" />
            </div>
        </div>
    </div>

    <div class="spoiler-log-options">
        <div class="spoiler-log-pools">
            <div class="row">
                <Pools AvailablePools="@this.availablePools" CanBeNone="@this.canBeNone" CurrentSeed="@this.currentSeed" IsSpoilerLog="true" Exceptions="@this.exceptions"
                       UpdateAvailablePools="@(pools => UpdateAvailablePools(pools))" UpdateCanBeNone="@(canBeNone => UpdateCanBeNone(canBeNone))" UpdateRandomizedOptions="@(randOptions => UpdateRandomizedOptions(randOptions))" 
                       UpdateCurrentSeed="@(currentSeed => UpdateCurrentSeed(currentSeed))" UpdateExceptions="@(exceptions => UpdateExceptions(exceptions))">
                </Pools>
            </div>
        </div>

        @if (this.randomizedOptions.Count > 0)
        {
        <hr />

        <div class="kh-modification-button">
            @if (this.modifications.Count > 0)
            {
                <button class="btn btn-danger" @onclick="ResetModifications">Reset Modifications</button>
            }
        </div>

        <div style="margin-top: 25px;"></div>

        <OptionsSubsection UpdateAvailableOptions="@this.UpdateAvailableOptions" UpdateRandomizedOptions="@this.UpdateRandomizedOptions" UpdateModifications="@this.UpdateModifications"
                           CurrentSeed="@this.currentSeed" AvailableOptions="@this.availableOptions" RandomizedOptions="@this.randomizedOptions"
                           ActionType="Options" SpoilerChecked="false" />
        }
    </div>
</div>


@code {
    private string currentSeed { get; set; }
    private bool canBeNone { get; set; }

    private Dictionary<string, RandomizeOptionEnum> availablePools = new Dictionary<string, RandomizeOptionEnum>
    {
        // World Categories - Custom Categories that contain Treasures, Events & Bonuses
        { "Olympus", RandomizeOptionEnum.Randomize }, { "Twilight Town", RandomizeOptionEnum.Randomize }, { "Toy Box", RandomizeOptionEnum.Randomize },
        { "Kingdom of Corona", RandomizeOptionEnum.Randomize }, { "Monstropolis", RandomizeOptionEnum.Randomize }, { "100 Acre Wood", RandomizeOptionEnum.Randomize },
        { "Arendelle", RandomizeOptionEnum.Randomize }, { "San Fransokyo", RandomizeOptionEnum.Randomize }, { "The Caribbean", RandomizeOptionEnum.Randomize },
        { "Keyblade Graveyard", RandomizeOptionEnum.Randomize }, { "Re:Mind", RandomizeOptionEnum.Randomize }, { "Dark World", RandomizeOptionEnum.Randomize },
        { "Unreality", RandomizeOptionEnum.Randomize },

        // Miscellaneous Categories
        { "Sora", RandomizeOptionEnum.Randomize }, { "Equipment Abilities", RandomizeOptionEnum.Replace }, { "Data Battle Rewards", RandomizeOptionEnum.Replace },
        { "Moogle Workshop", RandomizeOptionEnum.Randomize }, { "Fullcourse Abilities", RandomizeOptionEnum.Vanilla }, { "Lucky Emblems", RandomizeOptionEnum.Randomize },
        { "Flantastic Flans", RandomizeOptionEnum.Replace }, { "Minigames", RandomizeOptionEnum.Replace }, { "Battle Portals", RandomizeOptionEnum.Replace },

        // Always On - Proofs, Oathkeeper, Oblivion, Meow Wow, Gummiphone
        { "Always On", RandomizeOptionEnum.Replace }
    };

    private Dictionary<string, bool> exceptions = new Dictionary<string, bool>
    {
        { "Default Abilities", false },
        { "Default Critical Abilities", true },
        { "Early Critical Abilities", false }
    };

    private Dictionary<string, Dictionary<string, bool>> availableOptions = new();
    private Dictionary<DataTableEnum, Dictionary<string, Dictionary<string, string>>> randomizedOptions = new();

    //private Dictionary<string, Dictionary<string, bool>> tempOptions = new();

    private List<Tuple<Option, Option>> modifications = new();

    protected override void OnInitialized()
    {
        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }

    private void RandomizeOptions(ChangeEventArgs e)
    {
        this.currentSeed = e.Value.ToString();

        this.currentSeed = Regex.Replace(this.currentSeed, @"[^\w\-]", "");

        this.UpdateCurrentSeed(this.currentSeed);

        this.RandomizerService.RandomizeItems(this.currentSeed, ref this.availableOptions, ref this.randomizedOptions);

        this.UpdateAvailableOptions(this.availableOptions);
        this.UpdateRandomizedOptions(this.randomizedOptions);
    }

    private void ResetModifications()
    {
        this.modifications.Reverse();

        foreach (var (initialOption, swapOption) in this.modifications)
        {
            this.RandomizerService.UpdateRandomizedItem(ref this.randomizedOptions, initialOption.Category, initialOption.SubCategory, initialOption.Name, swapOption.Value,
                                                        swapOption.Category, swapOption.SubCategory, swapOption.Name, initialOption.Value);

        }

        this.UpdateRandomizedOptions(this.randomizedOptions);
        this.UpdateModifications(null, null);

        this.modifications = new();

        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }



    public void UpdateCurrentSeed(string currentSeed)
    {
        this.currentSeed = currentSeed;

        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }

    public void UpdateCanBeNone(bool canBeNone)
    {
        this.canBeNone = canBeNone;

        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }

    public void UpdateAvailablePools(Dictionary<string, RandomizeOptionEnum> availablePools)
    {
        this.availablePools = availablePools;


        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }

    public void UpdateExceptions(Dictionary<string, bool> exceptions)
    {
        this.exceptions = exceptions;

        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }

    public void UpdateAvailableOptions(Dictionary<string, Dictionary<string, bool>> availableOptions)
    {
        this.availableOptions = availableOptions;
        //this.tempOptions = availableOptions;

        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }

    public void UpdateRandomizedOptions(Dictionary<DataTableEnum, Dictionary<string, Dictionary<string, string>>> randomizedOptions)
    {
        this.randomizedOptions = randomizedOptions;

        this.RandomizerService.GetAvailableOptions(this.availablePools, ref this.availableOptions, false);
        this.UpdateAvailableOptions(this.availableOptions);

        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }

    public void UpdateModifications(Option initalOption, Option swapOption)
    {
        if (initalOption == null && swapOption == null)
            this.modifications = new();
        else
            this.modifications.Add(new Tuple<Option, Option>(initalOption, swapOption));


        InvokeAsync(() =>
        {
            StateHasChanged();
        });
    }

    public async void LoadSpoilerLog(InputFileChangeEventArgs e)
    {
        var file = e.File;

        var reader = await new StreamReader(file.OpenReadStream()).ReadToEndAsync();

        var spoilerLogFile = JsonSerializer.Deserialize<SpoilerLogFile>(reader);

        if (spoilerLogFile != null)
        {
            this.UpdateCurrentSeed(spoilerLogFile.SeedName);
            this.UpdateAvailablePools(spoilerLogFile.AvailablePools);
            this.UpdateExceptions(spoilerLogFile.Exceptions);

            this.RandomizerService.GetAvailableOptions(this.availablePools, ref this.availableOptions, false);
            this.UpdateAvailableOptions(this.availableOptions);

            this.randomizedOptions = this.RandomizerService.Process(this.currentSeed, this.availablePools, this.exceptions, this.canBeNone);
            this.UpdateRandomizedOptions(this.randomizedOptions);

            foreach (var item in spoilerLogFile.Modifications)
            {
                var initial = item.Item1;
                var swap = item.Item2;

                var initialOption = new Option { Category = (DataTableEnum)initial.Item1, SubCategory = initial.Item2, Name = initial.Item3, Value = initial.Item4 };
                var swapOption = new Option { Category = (DataTableEnum)swap.Item1, SubCategory = swap.Item2, Name = swap.Item3, Value = swap.Item4 };

                this.RandomizerService.UpdateRandomizedItem(ref randomizedOptions, initialOption.Category, initialOption.SubCategory, initialOption.Name, initialOption.Value,
                                                        swapOption.Category, swapOption.SubCategory, swapOption.Name, swapOption.Value);

                this.UpdateModifications(initialOption, swapOption);
            }


            await InvokeAsync(() =>
            {
                StateHasChanged();
            });
        }
    }
}